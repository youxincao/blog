#+BEGIN_COMMENT
.. title: Princeples of Design Pattern
.. slug: princeples-of-design-pattern
.. date: 2018-01-21 15:21:09 UTC+08:00
.. tags: draft
.. category: 
.. link: 
.. description: 
.. type: text
#+END_COMMENT


* 单一职责原则
比如说一个日记的类，维护了如何添加内容和标题。但是日记的类，不应该负责如何将日记持久化。
但是如何界定一个类的职责或许是最难的地方，需要工程的实战经验。
* 开放原则
Open for extension, close for modification.
主要是通过把不变的部分和变的部分隔离开来。通过增加新的类来实现新的需求，而不不需要修改
旧的，已经工作的代码。
* 代还原则
Object in a program should be replaceable with instances of their subtypes.


* GOF
** 结构型
*** 代理模式
为其他对象提供一种代理以控制对这个对象的访问。主要解决直接访问对象带来的问题。比如说服务在另外一个进程，
或者某些操作需要安全控制。
- 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不改能改变对代理类的接口。
- 和装饰器模式的区别：装饰器为了增强功能，但是代理模式为了加强控制.

*** 桥接模式 

*** 适配器模式
作为两个不兼容系统的桥梁。

*** 组合模式
将对象组合成属性结构已表示“部分-整体”的层次结构。在树形结构中，模糊了简单元素和复杂元素的概念，客户程序
可以像处理简单

*** 装饰模式
以对客户端透明的方式拓展对象的功能，是继承关系的一个替代方案。
*** 外观模式 
*** 享元模式
** 行为型
*** 备忘录模式
在不破坏封装的前提下，捕获一个对象的内部结构，并在这个对象之外保存这个状态，
这样可以在以后将对象恢复到原先保存的状态。
*** 中介者模式
定义一个中介对象来封装对象之间的交互。(感觉有点像总线结构)
*** 迭代器模式
用一种方法顺序访问一个局和对象中的元素，而又不暴露该对象的内部表示。
*** 解释器模式
给定一个语言，定义文法表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。（DSL？）
*** 命令模式
*** 职责连模式
*** 过滤器模式
